<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: geometry.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: geometry.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * This module handles various geometric shapes used in calculations for windowfactory.
 * @module geometry
 */
// TODO: Heavy refactor! Need to clean up all of these random functions. Make a simple library.
//       And no more resolving things down! It hurts performance in some cases,
//       and can make code unreadable, and hard to manage.

/*global windowfactory*/
windowfactory.geometry = (function () {
    // Utility functions:
    function minAbs() {
        let min = arguments[0];
        let minAbs = Math.abs(min);

        for (let index = 1; index &lt; arguments.length; index += 1) {
            let argAbs = Math.abs(arguments[index]);
            if (argAbs &lt; minAbs) {
                min = arguments[index];
                minAbs = argAbs;
            }
        }

        return {
            min: min,
            abs: minAbs
        };
    }

    /**
     * A Vector object.
     * @memberof module:geometry
     * @constructor
     * @param {number} left - The position of the vector's x-axis.
     * @param {number} top - The position of the vector's y-axis.
     */
    function Vector(left, top) {
        if (!(this instanceof Vector)) { return new Vector(left, top); }

        let obj = left;
        if (obj &amp;&amp; obj.constructor !== Number) {
            //new Vector(obj)
            this.left = obj.left;
            this.top = obj.top;
        } else {
            //new Vector(left, top)
            this.left = left;
            this.top = top;
        }
    }

    /**
     * Clone the current vector to a new object.
     * @method
     * @returns {module:geometry.Vector} A clone of this instance
     */
    Vector.prototype.clone = function () {
        return new Vector(this);
    };

    /**
     * Resolve this object down to a {@link module:geometry.Vector|Vector} instance.
     * Since this instance is already a vector, it returns itself.
     * @method
     * @returns {module:geometry.Vector} self
     */
    Vector.prototype.getVector = function () {
        // We have this method, so any prototype in this script will return their position,
        // and if they are one it will return itself.
        // This simplifies code, and prevents having to do a ton of checks.
        return this;
    }

    /**
     * Returns a BoundingBox instance version of this vector similar to:
     * new BoundingBox(Vector.left, Vector.top, Vector.left, Vector.top)
     * @method
     * @returns {module:geometry.BoundingBox}
     */
    Vector.prototype.getBoundingBox = function () {
        // We have this method, so any prototype in this script will return their position,
        // and if they are one it will return itself.
        // This simplifies code, and prevents having to do a ton of checks.
        return new BoundingBox(this.left, this.top, this.left, this.top);
    }

    /**
     * Returns a CollisionMesh instance version of this vector similar to:
     * new CollisionMesh(Vector.getBoundingBox())
     * @method
     * @returns {module:geometry.CollisionMesh}
     */
    Vector.prototype.getCollisionMesh = function () {
        return new CollisionMesh(this.getBoundingBox());
    };

    Vector.prototype.distanceSquared = function (left, top) {
        let other = new Vector(left, top);
        let diff = other.subtract(this);

        return diff.left * diff.left + diff.top * diff.top;
    };
    Vector.prototype.distance = function (left, top) {
        return Math.sqrt(this.distanceSquared(left, top));
    }
    Vector.prototype.set = function (other) {
        if (!other) { throw "set requires argument 'other'"; }
        other = other.getVector();
        //if (other.constructor !== Vector) { throw "set requires argument 'other' to resolve to type Vector"; }

        this.left = other.left;
        this.top = other.top;
        return this;
    };
    Vector.prototype.setMin = function (other) {
        if (!other) { throw "setMin requires argument 'other'"; }
        other = other.getVector();
        //if (other.constructor !== Vector) { throw "setMin requires argument 'other' to resolve to type Vector"; }

        if (Math.abs(other.left) &lt; Math.abs(this.left) || isNaN(this.left)) { this.left = other.left; }
        if (Math.abs(other.top) &lt; Math.abs(this.top) || isNaN(this.top)) { this.top = other.top; }
    };
    Vector.prototype.add = function (other) {
        if (!other) { throw "add requires argument 'other'"; }
        other = other.getVector();
        //if (other.constructor !== Vector) { throw "add requires argument 'other' to resolve to type Vector"; }

        this.left += other.left;
        this.top += other.top;
        return this;
    };
    /*Vector.add = function (a, b) {
        return a.clone().add(b);
    };*/
    Vector.prototype.subtract = function (other) {
        if (!other) { throw "subtract requires argument 'other'"; }
        other = other.getVector();
        //if (other.constructor !== Vector) { throw "subtract requires argument 'other' to resolve to type Vector"; }

        this.left -= other.left;
        this.top -= other.top;
        return this;
    };
    Vector.prototype.moveTo = function (left, top) {
        if (left &amp;&amp; left.constructor === Number) { this.left = left; }
        if (top &amp;&amp; top.constructor === Number) { this.top = top; }
        return this;
    };


    /**
     * A BoundingBox object.
     * @memberof module:geometry
     * @constructor
     * @param {number} left - The left position of the vector's x-axis.
     * @param {number} top - The top position of the vector's y-axis.
     * @param {number} right - The right position of the vector's x-axis.
     * @param {number} bottom - The bottom position of the vector's y-axis.
     */
    function BoundingBox(left, top, right, bottom) {
        if (!(this instanceof BoundingBox)) { return new BoundingBox(left, top, right, bottom); }

        let obj = left;
        if (obj &amp;&amp; obj.constructor !== Number) {
            if (obj.getBoundingBox) { obj = obj.getBoundingBox(); }
            //new BoundingBox(obj)
            this.left = obj.left;
            this.top = obj.top;
            this.right = obj.right;
            this.bottom = obj.bottom;
        } else {
            //new BoundingBox(left, top, right, bottom)
            this.left = left;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
    }
    BoundingBox.prototype.clone = function () {
        return new BoundingBox(this);
    };
    BoundingBox.prototype.isNaN = function () {
        return isNaN(this.left) || isNaN(this.top) || isNaN(this.right) || isNaN(this.bottom);
    };
    BoundingBox.prototype.getWidth = function () {
        return Math.abs(this.right - this.left);
    };
    BoundingBox.prototype.getHeight = function () {
        return Math.abs(this.bottom - this.top);
    };
    BoundingBox.prototype.getSize = function () {
        return new Vector(this.getWidth(), this.getHeight());
    };
    BoundingBox.prototype.getArea = function () {
        return this.getWidth() * this.getHeight();
    };
    BoundingBox.prototype.getPosition = function () {
        return new Vector(this.left, this.top);
    };
    BoundingBox.prototype.getBoundingBox = function () {
        // We have this method, so any prototype in this script will return their bounding box,
        // and if they are one it will return itself.
        // This simplifies code, and prevents having to do a ton of checks.
        return this;
    };
    BoundingBox.prototype.getCollisionMesh = function () {
        return new CollisionMesh(this);
    };
    BoundingBox.prototype.getCenterPosition = function () {
        return new Vector(this.left + this.getWidth() / 2, this.top + this.getHeight() / 2);
    };
    BoundingBox.prototype.difference = function (other) {
        if (!other) { throw "difference requires argument 'other'"; }
        other = other.getBoundingBox();
        /*if (other.constructor !== BoundingBox) {
            throw "difference requires argument 'other' to resolve to type BoundingBox";
        }*/

        return new BoundingBox(this.left - other.left, this.top - other.top,
                                this.right - other.right, this.bottom - other.bottom);
    };
    BoundingBox.prototype.getCenteredOnPosition = function (other) {
        if (!other) { throw "getCenteredOnPosition requires argument 'other'"; }
        other = other.getBoundingBox();
        /*if (other.constructor !== BoundingBox) {
            throw "getCenteredOnPosition requires argument 'other' to resolve to type BoundingBox";
        }*/

        return other.getCenterPosition().subtract(this.getCenterPosition().subtract(this.getPosition()));
    };
    BoundingBox.prototype.getIntersection = function (other) {
        if (!other) { throw "getIntersection requires argument 'other'"; }
        other = other.getBoundingBox();
        /*if (other.constructor !== BoundingBox) {
            throw "getIntersection requires argument 'other' to resolve to type BoundingBox";
        }*/

        let left = Math.max(this.left, other.left),
            top = Math.max(this.top, other.top),
            right = Math.min(this.right, other.right),
            bottom = Math.min(this.bottom, other.bottom);

        if ((left &lt; right &amp;&amp; top &lt; bottom) || (left === right &amp;&amp; top &lt; bottom) || (top === bottom &amp;&amp; left &lt; right)) {
            return new BoundingBox(left, top, right, bottom);
        } else if (left === right &amp;&amp; top === bottom) {
            return new Vector(left, top);
        }
    };
    BoundingBox.prototype.getDistanceSquaredToPoint = function (left, top) {
        let other = new Vector(left, top);
        let cLeft = (other.left &lt;= this.left ? this.left : (other.left >= this.right ? this.right : other.left));
        let cTop = (other.top &lt;= this.top ? this.top : (other.top >= this.bottom ? this.bottom : other.top));
        let cPos = new Vector(cLeft, cTop);

        return cPos.distanceSquared(other);
    };
    BoundingBox.prototype.getDistanceToPoint = function (left, top) {
        return Math.sqrt(this.getDistanceSquaredToPoint(left, top));
    };
    BoundingBox.prototype.set = function (left, top, right, bottom) {
        let newBounds = new BoundingBox(left, top, right, bottom);
        this.left = newBounds.left;
        this.top = newBounds.top;
        this.right = newBounds.right;
        this.bottom = newBounds.bottom;
        return this;
    };
    BoundingBox.prototype.moveTo = function (left, top) {
        let newPosition = new Vector(left, top);
        this.right = newPosition.left + (this.right - this.left);
        this.left = newPosition.left;
        this.bottom = newPosition.top + (this.bottom - this.top);
        this.top = newPosition.top;
        return this;
    };
    BoundingBox.prototype.moveBy = function (left, top) {
        let newPosition = new Vector(left, top);
        this.left += newPosition.left;
        this.right += newPosition.left;
        this.top += newPosition.top;
        this.bottom += newPosition.top;
        return this;
    };
    BoundingBox.prototype.resizeTo = function (width, height, anchor) {
        // NOTE: anchor supports "top-left", "top-right", "bottom-left", or "bottom-right". By default it is "top-left".
        // NOTE: anchor also supports being passed as a position. Allowing the resize anchor to be anywhere other than
        //       the predefined strings.
        let curSize = this.getSize();
        let newSize = new Vector(width || curSize.left, height || curSize.top);
        anchor = anchor || "top-left";
        if (typeof anchor === "string" || anchor instanceof String) {
            let anchorStr = anchor;
            anchor = this.getPosition();
            if (anchorStr.indexOf("right") >= 0) { anchor.left += curSize.left; }
            if (anchorStr.indexOf("bottom") >= 0) { anchor.top += curSize.top; }
        }

        this.left += (anchor.left - this.left) * (curSize.left - newSize.left) / curSize.left;
        this.right += (anchor.left - this.right) * (curSize.left - newSize.left) / curSize.left;
        this.top += (anchor.top - this.top) * (curSize.top - newSize.top) / curSize.top;
        this.bottom += (anchor.top - this.bottom) * (curSize.top - newSize.top) / curSize.top;
        //this.left += (this.left - anchor.left) / curSize.left * newSize.left;
        //this.right += (this.right - anchor.left) / curSize.left * newSize.left;
        //this.top += (this.top - anchor.top) / curSize.top * newSize.top;
        //this.bottom += (this.bottom - anchor.top) / curSize.top * newSize.top;
        return this;
    };
    BoundingBox.prototype.isContains = function (other) {
        if (!other) { throw "isContains requires argument 'other'"; }
        other = other.getBoundingBox();
        /*if (other.constructor !== BoundingBox) {
            throw "isContains requires argument 'other' to resolve to type BoundingBox";
        }*/

        return other.left >= this.left &amp;&amp; other.right &lt;= this.right &amp;&amp; other.top >= this.top &amp;&amp; other.bottom &lt;= this.bottom;
    };
    BoundingBox.prototype.someContains = function (others) {
        if (!others) { throw "someContains requires argument 'others'"; }
        if (others.constructor !== Array) { throw "someContains requires argument 'others' of type Array"; }

        for (let index = 0; index &lt; others.length; index += 1) {
            if (this.isContains(others[index])) { return true; }
        }
        return false;
    };
    BoundingBox.prototype.isTouching = function (other) {
        if (!other) { throw "isTouching requires argument 'other'"; }
        other = other.getBoundingBox();
        /*if (other.constructor !== BoundingBox) {
            throw "isTouching requires argument 'other' to resolve to type BoundingBox";
        }*/

        return ((this.top &lt;= other.bottom &amp;&amp; this.bottom >= other.top)
                &amp;&amp; (this.left === other.right || this.right === other.left)) ||
                ((this.left &lt;= other.right &amp;&amp; this.right >= other.left)
                &amp;&amp; (this.top === other.bottom || this.bottom === other.top));
    };
    BoundingBox.prototype.getEdgeTouching = function (others) {
        if (!others) { throw "getEdgeTouching requires argument 'others'"; }
        if (others.constructor !== Array) { others = [others]; }

        for (let index = 0; index &lt; others.length; index += 1) {
            let other = others[index].getBoundingBox();
            if (this.top &lt;= other.bottom &amp;&amp; this.bottom >= other.top) {
                if (this.left === other.right) { return "left"; }
                if (this.right === other.left) { return "right"; }
            }
            if (this.left &lt;= other.right &amp;&amp; this.right >= other.left) {
                if (this.top === other.bottom) { return "top"; }
                if (this.bottom === other.top) { return "bottom"; }
            }
        }
    };
    BoundingBox.prototype.getOtherEdgeTouching = function (others) {
        if (!others) { throw "getOtherEdgeTouching requires argument 'others'"; }
        if (others.constructor !== Array) { others = [others]; }

        for (let index = 0; index &lt; others.length; index += 1) {
            let other = others[index].getBoundingBox();
            if (this.top &lt;= other.bottom &amp;&amp; this.bottom >= other.top) {
                if (this.left === other.right) { return "right"; }
                if (this.right === other.left) { return "left"; }
            }
            if (this.left &lt;= other.right &amp;&amp; this.right >= other.left) {
                if (this.top === other.bottom) { return "bottom"; }
                if (this.bottom === other.top) { return "top"; }
            }
        }
    };
    BoundingBox.prototype.getEdgeClosestOrder = function (other) {
        if (!other) { throw "getEdgeClosest requires argument 'other'"; }
        other = other.getBoundingBox();
        /*if (other.constructor !== BoundingBox) {
            throw "getEdgeClosest requires argument 'other' to resolve to type BoundingBox";
        }*/

        let centerPos = this.getCenterPosition();
        let dis = [];
        dis.push({
            "edge": "left",
            dis: other.getDistanceSquaredToPoint(this.left, centerPos.top)
        });
        dis.push({
            "edge": "top",
            dis: other.getDistanceSquaredToPoint(centerPos.left, this.top)
        });
        dis.push({
            "edge": "right",
            dis: other.getDistanceSquaredToPoint(this.right, centerPos.top)
        });
        dis.push({
            "edge": "bottom",
            dis: other.getDistanceSquaredToPoint(centerPos.left, this.bottom)
        });
        dis.sort(function (a, b) {
            return a.dis - b.dis;
        });

        return dis.map(function (dis) { return dis.edge; });
    };
    BoundingBox.prototype.getEdgeClosest = function (other) {
        let edges = this.getEdgeClosestOrder(other);
        return edges[0];
    };
    BoundingBox.prototype.getSnapDelta = function (other, snapDistance) {
        if (!other) { throw "getSnapDelta requires argument 'other'"; }
        other = other.getBoundingBox();
        snapDistance = snapDistance || 5;
        /*if (other.constructor !== BoundingBox) {
            throw "getSnapDelta requires argument 'other' to resolve to type BoundingBox";
        }*/

        let snapDelta = new Vector(NaN, NaN);

        if (this.top &lt;= other.bottom &amp;&amp; this.bottom >= other.top) {
            // Handle x-snap:
            const leftRightDis = minAbs(other.left - this.right, other.right - this.left);
            if (leftRightDis.abs &lt;= snapDistance) { // this.LeftRightSnapTo(other)
                snapDelta.left = leftRightDis.min;

                // Handle y-subsnap:
                const topBottomDis = minAbs(other.top - this.top, other.bottom - this.bottom);
                if (topBottomDis.abs &lt;= snapDistance) { // this.TopBottomSubSnapTo(other)
                    snapDelta.top = topBottomDis.min;
                }
            }
        } else if (this.left &lt;= other.right &amp;&amp; this.right >= other.left) {
            // Handle y-snap:
            const topBottomDis = minAbs(other.top - this.bottom, other.bottom - this.top);
            if (topBottomDis.abs &lt;= snapDistance) { // this.TopBottomSnapTo(other)
                snapDelta.top = topBottomDis.min;

                // Handle x-subsnap:
                const leftRightDis = minAbs(other.left - this.left, other.right - this.right);
                if (leftRightDis.abs &lt;= snapDistance) { // this.LeftRightSubSnapTo(other)
                    snapDelta.left = leftRightDis.min;
                }
            }
        }

        return snapDelta;
    };
    BoundingBox.prototype.someTouching = function (others) {
        if (!others) { throw "someTouching requires argument 'others'"; }
        if (others.constructor !== Array) { throw "someTouching requires argument 'others' of type Array"; }

        for (let index = 0; index &lt; others.length; index += 1) {
            if (this.isTouching(others[index])) { return true; }
        }
        return false;
    };
    BoundingBox.prototype.isColliding = function (other) {
        if (!other) { throw "isColliding requires argument 'other'"; }
        other = other.getBoundingBox();
        /*if (other.constructor !== BoundingBox) {
            throw "isColliding requires argument 'other' to resolve to type BoundingBox";
        }*/

        return this.left &lt; other.right &amp;&amp; this.right > other.left &amp;&amp; this.top &lt; other.bottom &amp;&amp; this.bottom > other.top;
    };
    BoundingBox.prototype.someColliding = function (others) {
        if (!others) { throw "someColliding requires argument 'others'"; }
        if (others.constructor !== Array) { throw "someColliding requires argument 'others' of type Array"; }

        for (let index = 0; index &lt; others.length; index += 1) {
            if (this.isColliding(others[index])) { return true; }
        }
        return false;
    };
    BoundingBox.prototype.getColliding = function (others) {
        if (!others) { throw "getColliding requires argument 'others'"; }
        if (others.constructor !== Array) { throw "getColliding requires argument 'others' of type Array"; }

        for (let index = 0; index &lt; others.length; index += 1) {
            if (this.isColliding(others[index])) { return others[index]; }
        }
    };
    BoundingBox.prototype.isTouchingEdge = function (other) {
        if (!other) { throw "isTouchingEdge requires argument 'other'"; }
        other = other.getBoundingBox();
        /*if (other.constructor !== BoundingBox) {
            throw "isTouchingEdge requires argument 'other' to resolve to type BoundingBox";
        }*/

        return this.left === other.right || this.right === other.left
                || this.top === other.bottom || this.bottom === other.top;
    };
    /*BoundingBox.prototype.getXEdgeDistance = function (other) {
        if (!others) { throw "getColliding requires argument 'others'"; }
        if (others.constructor !== Array) { throw "getColliding requires argument 'others' of type Array"; }

        let distance = 1000000; // Arbitrary distance
        for (let index = 0; index &lt; this.boxes.length; index += 1) {
            for (let j = 0; j &lt; other.boxes.length; j += 1) {
                distance = Math.min(distance, this.boxes[index].getXEdgeDistance(other.boxes[j]));
            }
        }
        return distance;
    };*/

    /**
     * A CollisionMesh object.
     * @memberof module:geometry
     * @constructor
     * @param {module:geometry.BoundingBox[]} boxes - An array of objects thatg resolve to BoundingBox.
     */
    function CollisionMesh(boxes, opts) {
        if (!(this instanceof CollisionMesh)) { return new CollisionMesh(boxes); }
        opts = opts || {};

        if (!boxes) { throw "CollisionMesh constructor requires argument 'boxes'"; }
        if (boxes.constructor !== Array) { boxes = [boxes]; }
        this.boxes = [];
        for (let index = 0; index &lt; boxes.length; index += 1) {
            if (boxes[index].constructor === BoundingBox) {
                this.boxes.push(boxes[index]);
            } else if (boxes[index].constructor === CollisionMesh) {
                this.boxes = this.boxes.concat(boxes[index].boxes);
            } else {
                this.boxes = this.boxes.concat(boxes[index].getCollisionMesh(opts).boxes);
            }
        }
    }
    CollisionMesh.prototype.clone = function () {
        let boxes = [];
        for (let index = 0; index &lt; this.boxes; index += 1) {
            boxes[index] = this.boxes[index].clone();
        }
        return new CollisionMesh(boxes);
    };
    CollisionMesh.prototype.getWidth = function () {
        if (this.boxes.length === 0) { return 0; }

        let left = this.boxes[0].left,
            right = this.boxes[0].right;

        for (let index = 1; index &lt; this.boxes.length; index += 1) {
            // This assumes left is least, and right is most in terms of value:
            left = Math.min(left, this.boxes[index].left);
            right = Math.max(right, this.boxes[index].right);
        }

        return right - left;
    };
    CollisionMesh.prototype.getHeight = function () {
        if (this.boxes.length === 0) { return 0; }

        let top = this.boxes[0].top,
            bottom = this.boxes[0].bottom;

        for (let index = 1; index &lt; this.boxes.length; index += 1) {
            // This assumes top is least, and bottom is most in terms of value:
            top = Math.min(top, this.boxes[index].top);
            bottom = Math.max(bottom, this.boxes[index].bottom);
        }

        return bottom - top;
    };
    CollisionMesh.prototype.getSize = function () {
        return new Vector(this.getWidth(), this.getHeight());
    };
    CollisionMesh.prototype.getPosition = function () {
        return new Vector(this.getBoundingBox());
    };
    CollisionMesh.prototype.getBoundingBox = function () {
        if (this.boxes.length === 0) { return 0; }

        let left = this.boxes[0].left,
            top = this.boxes[0].top,
            right = this.boxes[0].right,
            bottom = this.boxes[0].bottom;

        for (let index = 1; index &lt; this.boxes.length; index += 1) {
            left = Math.min(left, this.boxes[index].left);
            top = Math.min(top, this.boxes[index].top);
            right = Math.max(right, this.boxes[index].right);
            bottom = Math.max(bottom, this.boxes[index].bottom);
        }

        return new BoundingBox(left, top, right, bottom);
    };
    CollisionMesh.prototype.getCollisionMesh = function () {
        return this;
    };
    CollisionMesh.prototype.moveTo = function (left, top) {
        let newPosition = new Vector(left, top);
        this.moveBy(newPosition.subtract(this.getPosition()));
        return this;
    };
    CollisionMesh.prototype.moveBy = function (left, top) {
        let newPosition = new Vector(left || 0, top || 0);
        for (let index = 0; index &lt; this.boxes.length; index += 1) {
            this.boxes[index].moveBy(newPosition);
        }
        return this;
    };
    CollisionMesh.prototype.isContains = function (other) {
        // TODO: Needs to check that all of other's boxes are contained by this's boxes. NOT check if only one is!
        if (!other) { throw "isContains requires argument 'other'"; }
        other = (other.constructor === Array ? new CollisionMesh(other) : other.getCollisionMesh());
        /*if (other.constructor !== CollisionMesh) {
            throw "isContains requires argument 'other' to resolve to type CollisionMesh";
        }*/

        for (let index = 0; index &lt; this.boxes.length; index += 1) {
            if (this.boxes[index].someContains(other.boxes)) { return true; }
        }
        return false;
    };
    CollisionMesh.prototype.someContains = function (other) {
        if (!other) { throw "someContains requires argument 'other'"; }
        other = (other.constructor === Array ? new CollisionMesh(other) : other.getCollisionMesh());
        /*if (other.constructor !== CollisionMesh) {
            throw "someContains requires argument 'other' to resolve to type CollisionMesh";
        }*/

        for (let index = 0; index &lt; this.boxes.length; index += 1) {
            if (this.boxes[index].someContains(other.boxes)) { return true; }
        }
        return false;
    };
    CollisionMesh.prototype.isTouching = function (other) {
        if (!other) { throw "isTouching requires argument 'other'"; }
        other = (other.constructor === Array ? new CollisionMesh(other) : other.getCollisionMesh());
        /*if (other.constructor !== CollisionMesh) {
            throw "isTouching requires argument 'other' to resolve to type CollisionMesh";
        }*/

        for (let index = 0; index &lt; this.boxes.length; index += 1) {
            if (this.boxes[index].someTouching(other.boxes)) { return true; }
        }
        return false;
    };
    CollisionMesh.prototype.someTouching = function (others) {
        if (!others) { throw "someTouching requires argument 'others'"; }
        if (others.constructor !== Array) { throw "someTouching requires argument 'others' to resolve to type Array"; }

        for (let index = 0; index &lt; others.length; index += 1) {
            if (this.isTouching(others[index])) { return true; }
        }
        return false;
    };
    CollisionMesh.prototype.isColliding = function (other) {
        if (!other) { throw "isColliding requires argument 'other'"; }
        other = (other.constructor === Array ? new CollisionMesh(other) : other.getCollisionMesh());
        /*if (other.constructor !== CollisionMesh) {
            throw "isColliding requires argument 'other' to resolve to type CollisionMesh";
        }*/

        for (let index = 0; index &lt; this.boxes.length; index += 1) {
            if (this.boxes[index].someColliding(other.boxes)) { return true; }
        }
        return false;
    };
    CollisionMesh.prototype.someColliding = function (others) {
        if (!others) { throw "someColliding requires argument 'others'"; }
        if (others.constructor !== Array) { throw "someColliding requires argument 'others' to resolve to type Array"; }

        for (let i = 0; i &lt; others.length; i += 1) {
            for (let j = 0; j &lt; this.boxes.length; j += 1) {
                if (this.boxes[j].isColliding(others[i])) { return true; }
            }
        }
        return false;
    };
    CollisionMesh.prototype.getColliding = function (other) {
        if (!other) { throw "getColliding requires argument 'other'"; }
        other = (other.constructor === Array ? new CollisionMesh(other) : other.getCollisionMesh());
        /*if (other.constructor !== CollisionMesh) {
            throw "getColliding requires argument 'other' to resolve to type CollisionMesh";
        }*/

        for (let index = 0; index &lt; this.boxes.length; index += 1) {
            let collided = this.boxes[index].getColliding(other.boxes);
            if (collided) { return collided; }
        }
    };
    /*CollisionMesh.prototype.getXEdgeDistance = function (other) {
        if (!other) { throw "isTouching requires argument 'other'"; }
        other = (other.constructor === Array ? new CollisionMesh(other) : other.getCollisionMesh());
        if (other.constructor !== CollisionMesh) {
            throw "isTouching requires argument 'other' to resolve to type CollisionMesh";
        }

        let distance = 1000000; // Arbitrary distance
        for (let index = 0; index &lt; this.boxes.length; index += 1) {
            for (let j = 0; j &lt; other.boxes.length; j += 1) {
                distance = Math.min(distance, this.boxes[index].getXEdgeDistance(other.boxes[j]));
            }
        }
        return distance;
    };*/

    return {
        Vector: Vector,
        /**
         * A Position object.
         * @memberof module:geometry
         * @constructor
         * @param {number} left - The position of the vector's x-axis.
         * @param {number} top - The position of the vector's y-axis.
         * @see {@link module:geometry.Vector|Vector} for further information.
         */
        Position: Vector,
        /**
         * A Size object.
         * @memberof module:geometry
         * @constructor
         * @param {number} left - The position of the vector's x-axis.
         * @param {number} top - The position of the vector's y-axis.
         * @see {@link module:geometry.Vector|Vector} for further information.
         */
        Size: Vector,
        BoundingBox: BoundingBox,
        CollisionMesh: CollisionMesh
    };
})();</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-geometry.html">geometry</a></li></ul><h3>Classes</h3><ul><li><a href="EventHandler.html">EventHandler</a></li><li><a href="module-geometry.BoundingBox.html">BoundingBox</a></li><li><a href="module-geometry.CollisionMesh.html">CollisionMesh</a></li><li><a href="module-geometry.Position.html">Position</a></li><li><a href="module-geometry.Size.html">Size</a></li><li><a href="module-geometry.Vector.html">Vector</a></li><li><a href="Window.html">Window</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Fri Jul 29 2016 14:15:03 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
